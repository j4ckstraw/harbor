// Code generated by go-swagger; DO NOT EDIT.

package user

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"
)

// SetCliSecretHandlerFunc turns a function with the right signature into a set cli secret handler
type SetCliSecretHandlerFunc func(SetCliSecretParams, interface{}) middleware.Responder

// Handle executing the request and returning a response
func (fn SetCliSecretHandlerFunc) Handle(params SetCliSecretParams, principal interface{}) middleware.Responder {
	return fn(params, principal)
}

// SetCliSecretHandler interface for that can handle valid set cli secret params
type SetCliSecretHandler interface {
	Handle(SetCliSecretParams, interface{}) middleware.Responder
}

// NewSetCliSecret creates a new http.Handler for the set cli secret operation
func NewSetCliSecret(ctx *middleware.Context, handler SetCliSecretHandler) *SetCliSecret {
	return &SetCliSecret{Context: ctx, Handler: handler}
}

/*SetCliSecret swagger:route PUT /users/{user_id}/cli_secret user setCliSecret

Set CLI secret for a user.

This endpoint let user generate a new CLI secret for himself.  This API only works when auth mode is set to 'OIDC'. Once this API returns with successful status, the old secret will be invalid, as there will be only one CLI secret for a user.

*/
type SetCliSecret struct {
	Context *middleware.Context
	Handler SetCliSecretHandler
}

func (o *SetCliSecret) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		r = rCtx
	}
	var Params = NewSetCliSecretParams()

	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		r = aCtx
	}
	var principal interface{}
	if uprinc != nil {
		principal = uprinc
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request

	o.Context.Respond(rw, r, route.Produces, route, res)

}
