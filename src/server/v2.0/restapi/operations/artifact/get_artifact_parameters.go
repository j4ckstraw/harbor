// Code generated by go-swagger; DO NOT EDIT.

package artifact

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewGetArtifactParams creates a new GetArtifactParams object
// with the default values initialized.
func NewGetArtifactParams() GetArtifactParams {

	var (
		// initialize parameters with default values

		xAcceptVulnerabilitiesDefault = string("application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0")

		pageDefault     = int64(1)
		pageSizeDefault = int64(10)

		withImmutableStatusDefault = bool(false)
		withLabelDefault           = bool(false)
		withScanOverviewDefault    = bool(false)
		withSignatureDefault       = bool(false)
		withTagDefault             = bool(true)
	)

	return GetArtifactParams{
		XAcceptVulnerabilities: &xAcceptVulnerabilitiesDefault,

		Page: &pageDefault,

		PageSize: &pageSizeDefault,

		WithImmutableStatus: &withImmutableStatusDefault,

		WithLabel: &withLabelDefault,

		WithScanOverview: &withScanOverviewDefault,

		WithSignature: &withSignatureDefault,

		WithTag: &withTagDefault,
	}
}

// GetArtifactParams contains all the bound params for the get artifact operation
// typically these are obtained from a http.Request
//
// swagger:parameters getArtifact
type GetArtifactParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it.
	Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'
	  In: header
	  Default: "application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0"
	*/
	XAcceptVulnerabilities *string
	/*An unique ID for the request
	  Min Length: 1
	  In: header
	*/
	XRequestID *string
	/*The page number
	  In: query
	  Default: 1
	*/
	Page *int64
	/*The size of per page
	  Maximum: 100
	  In: query
	  Default: 10
	*/
	PageSize *int64
	/*The name of the project
	  Required: true
	  In: path
	*/
	ProjectName string
	/*The reference of the artifact, can be digest or tag
	  Required: true
	  In: path
	*/
	Reference string
	/*The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb
	  Required: true
	  In: path
	*/
	RepositoryName string
	/*Specify whether the immutable status is inclued inside the tags of the returning artifacts. Only works when setting "with_tag=true"
	  In: query
	  Default: false
	*/
	WithImmutableStatus *bool
	/*Specify whether the labels are inclued inside the returning artifacts
	  In: query
	  Default: false
	*/
	WithLabel *bool
	/*Specify whether the scan overview is inclued inside the returning artifacts
	  In: query
	  Default: false
	*/
	WithScanOverview *bool
	/*Specify whether the signature is inclued inside the returning artifacts
	  In: query
	  Default: false
	*/
	WithSignature *bool
	/*Specify whether the tags are inclued inside the returning artifacts
	  In: query
	  Default: true
	*/
	WithTag *bool
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewGetArtifactParams() beforehand.
func (o *GetArtifactParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	if err := o.bindXAcceptVulnerabilities(r.Header[http.CanonicalHeaderKey("X-Accept-Vulnerabilities")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindXRequestID(r.Header[http.CanonicalHeaderKey("X-Request-Id")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	qPage, qhkPage, _ := qs.GetOK("page")
	if err := o.bindPage(qPage, qhkPage, route.Formats); err != nil {
		res = append(res, err)
	}

	qPageSize, qhkPageSize, _ := qs.GetOK("page_size")
	if err := o.bindPageSize(qPageSize, qhkPageSize, route.Formats); err != nil {
		res = append(res, err)
	}

	rProjectName, rhkProjectName, _ := route.Params.GetOK("project_name")
	if err := o.bindProjectName(rProjectName, rhkProjectName, route.Formats); err != nil {
		res = append(res, err)
	}

	rReference, rhkReference, _ := route.Params.GetOK("reference")
	if err := o.bindReference(rReference, rhkReference, route.Formats); err != nil {
		res = append(res, err)
	}

	rRepositoryName, rhkRepositoryName, _ := route.Params.GetOK("repository_name")
	if err := o.bindRepositoryName(rRepositoryName, rhkRepositoryName, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithImmutableStatus, qhkWithImmutableStatus, _ := qs.GetOK("with_immutable_status")
	if err := o.bindWithImmutableStatus(qWithImmutableStatus, qhkWithImmutableStatus, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithLabel, qhkWithLabel, _ := qs.GetOK("with_label")
	if err := o.bindWithLabel(qWithLabel, qhkWithLabel, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithScanOverview, qhkWithScanOverview, _ := qs.GetOK("with_scan_overview")
	if err := o.bindWithScanOverview(qWithScanOverview, qhkWithScanOverview, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithSignature, qhkWithSignature, _ := qs.GetOK("with_signature")
	if err := o.bindWithSignature(qWithSignature, qhkWithSignature, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithTag, qhkWithTag, _ := qs.GetOK("with_tag")
	if err := o.bindWithTag(qWithTag, qhkWithTag, route.Formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindXAcceptVulnerabilities binds and validates parameter XAcceptVulnerabilities from header.
func (o *GetArtifactParams) bindXAcceptVulnerabilities(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetArtifactParams()
		return nil
	}

	o.XAcceptVulnerabilities = &raw

	return nil
}

// bindXRequestID binds and validates parameter XRequestID from header.
func (o *GetArtifactParams) bindXRequestID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.XRequestID = &raw

	if err := o.validateXRequestID(formats); err != nil {
		return err
	}

	return nil
}

// validateXRequestID carries on validations for parameter XRequestID
func (o *GetArtifactParams) validateXRequestID(formats strfmt.Registry) error {

	if err := validate.MinLength("X-Request-Id", "header", (*o.XRequestID), 1); err != nil {
		return err
	}

	return nil
}

// bindPage binds and validates parameter Page from query.
func (o *GetArtifactParams) bindPage(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetArtifactParams()
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("page", "query", "int64", raw)
	}
	o.Page = &value

	return nil
}

// bindPageSize binds and validates parameter PageSize from query.
func (o *GetArtifactParams) bindPageSize(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetArtifactParams()
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("page_size", "query", "int64", raw)
	}
	o.PageSize = &value

	if err := o.validatePageSize(formats); err != nil {
		return err
	}

	return nil
}

// validatePageSize carries on validations for parameter PageSize
func (o *GetArtifactParams) validatePageSize(formats strfmt.Registry) error {

	if err := validate.MaximumInt("page_size", "query", int64(*o.PageSize), 100, false); err != nil {
		return err
	}

	return nil
}

// bindProjectName binds and validates parameter ProjectName from path.
func (o *GetArtifactParams) bindProjectName(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route

	o.ProjectName = raw

	return nil
}

// bindReference binds and validates parameter Reference from path.
func (o *GetArtifactParams) bindReference(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route

	o.Reference = raw

	return nil
}

// bindRepositoryName binds and validates parameter RepositoryName from path.
func (o *GetArtifactParams) bindRepositoryName(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route

	o.RepositoryName = raw

	return nil
}

// bindWithImmutableStatus binds and validates parameter WithImmutableStatus from query.
func (o *GetArtifactParams) bindWithImmutableStatus(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetArtifactParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_immutable_status", "query", "bool", raw)
	}
	o.WithImmutableStatus = &value

	return nil
}

// bindWithLabel binds and validates parameter WithLabel from query.
func (o *GetArtifactParams) bindWithLabel(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetArtifactParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_label", "query", "bool", raw)
	}
	o.WithLabel = &value

	return nil
}

// bindWithScanOverview binds and validates parameter WithScanOverview from query.
func (o *GetArtifactParams) bindWithScanOverview(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetArtifactParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_scan_overview", "query", "bool", raw)
	}
	o.WithScanOverview = &value

	return nil
}

// bindWithSignature binds and validates parameter WithSignature from query.
func (o *GetArtifactParams) bindWithSignature(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetArtifactParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_signature", "query", "bool", raw)
	}
	o.WithSignature = &value

	return nil
}

// bindWithTag binds and validates parameter WithTag from query.
func (o *GetArtifactParams) bindWithTag(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetArtifactParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_tag", "query", "bool", raw)
	}
	o.WithTag = &value

	return nil
}
