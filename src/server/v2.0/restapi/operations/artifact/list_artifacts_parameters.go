// Code generated by go-swagger; DO NOT EDIT.

package artifact

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewListArtifactsParams creates a new ListArtifactsParams object
// with the default values initialized.
func NewListArtifactsParams() ListArtifactsParams {

	var (
		// initialize parameters with default values

		xAcceptVulnerabilitiesDefault = string("application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0")

		pageDefault     = int64(1)
		pageSizeDefault = int64(10)

		withImmutableStatusDefault = bool(false)
		withLabelDefault           = bool(false)
		withScanOverviewDefault    = bool(false)
		withSignatureDefault       = bool(false)
		withTagDefault             = bool(true)
	)

	return ListArtifactsParams{
		XAcceptVulnerabilities: &xAcceptVulnerabilitiesDefault,

		Page: &pageDefault,

		PageSize: &pageSizeDefault,

		WithImmutableStatus: &withImmutableStatusDefault,

		WithLabel: &withLabelDefault,

		WithScanOverview: &withScanOverviewDefault,

		WithSignature: &withSignatureDefault,

		WithTag: &withTagDefault,
	}
}

// ListArtifactsParams contains all the bound params for the list artifacts operation
// typically these are obtained from a http.Request
//
// swagger:parameters listArtifacts
type ListArtifactsParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it.
	Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'
	  In: header
	  Default: "application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0"
	*/
	XAcceptVulnerabilities *string
	/*An unique ID for the request
	  Min Length: 1
	  In: header
	*/
	XRequestID *string
	/*The page number
	  In: query
	  Default: 1
	*/
	Page *int64
	/*The size of per page
	  Maximum: 100
	  In: query
	  Default: 10
	*/
	PageSize *int64
	/*The name of the project
	  Required: true
	  In: path
	*/
	ProjectName string
	/*Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]
	  In: query
	*/
	Q *string
	/*The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -> a%252Fb
	  Required: true
	  In: path
	*/
	RepositoryName string
	/*Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"
	  In: query
	*/
	Sort *string
	/*Specify whether the immutable status is included inside the tags of the returning artifacts. Only works when setting "with_tag=true"
	  In: query
	  Default: false
	*/
	WithImmutableStatus *bool
	/*Specify whether the labels are included inside the returning artifacts
	  In: query
	  Default: false
	*/
	WithLabel *bool
	/*Specify whether the scan overview is included inside the returning artifacts
	  In: query
	  Default: false
	*/
	WithScanOverview *bool
	/*Specify whether the signature is included inside the tags of the returning artifacts. Only works when setting "with_tag=true"
	  In: query
	  Default: false
	*/
	WithSignature *bool
	/*Specify whether the tags are included inside the returning artifacts
	  In: query
	  Default: true
	*/
	WithTag *bool
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewListArtifactsParams() beforehand.
func (o *ListArtifactsParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	if err := o.bindXAcceptVulnerabilities(r.Header[http.CanonicalHeaderKey("X-Accept-Vulnerabilities")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindXRequestID(r.Header[http.CanonicalHeaderKey("X-Request-Id")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	qPage, qhkPage, _ := qs.GetOK("page")
	if err := o.bindPage(qPage, qhkPage, route.Formats); err != nil {
		res = append(res, err)
	}

	qPageSize, qhkPageSize, _ := qs.GetOK("page_size")
	if err := o.bindPageSize(qPageSize, qhkPageSize, route.Formats); err != nil {
		res = append(res, err)
	}

	rProjectName, rhkProjectName, _ := route.Params.GetOK("project_name")
	if err := o.bindProjectName(rProjectName, rhkProjectName, route.Formats); err != nil {
		res = append(res, err)
	}

	qQ, qhkQ, _ := qs.GetOK("q")
	if err := o.bindQ(qQ, qhkQ, route.Formats); err != nil {
		res = append(res, err)
	}

	rRepositoryName, rhkRepositoryName, _ := route.Params.GetOK("repository_name")
	if err := o.bindRepositoryName(rRepositoryName, rhkRepositoryName, route.Formats); err != nil {
		res = append(res, err)
	}

	qSort, qhkSort, _ := qs.GetOK("sort")
	if err := o.bindSort(qSort, qhkSort, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithImmutableStatus, qhkWithImmutableStatus, _ := qs.GetOK("with_immutable_status")
	if err := o.bindWithImmutableStatus(qWithImmutableStatus, qhkWithImmutableStatus, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithLabel, qhkWithLabel, _ := qs.GetOK("with_label")
	if err := o.bindWithLabel(qWithLabel, qhkWithLabel, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithScanOverview, qhkWithScanOverview, _ := qs.GetOK("with_scan_overview")
	if err := o.bindWithScanOverview(qWithScanOverview, qhkWithScanOverview, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithSignature, qhkWithSignature, _ := qs.GetOK("with_signature")
	if err := o.bindWithSignature(qWithSignature, qhkWithSignature, route.Formats); err != nil {
		res = append(res, err)
	}

	qWithTag, qhkWithTag, _ := qs.GetOK("with_tag")
	if err := o.bindWithTag(qWithTag, qhkWithTag, route.Formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindXAcceptVulnerabilities binds and validates parameter XAcceptVulnerabilities from header.
func (o *ListArtifactsParams) bindXAcceptVulnerabilities(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewListArtifactsParams()
		return nil
	}

	o.XAcceptVulnerabilities = &raw

	return nil
}

// bindXRequestID binds and validates parameter XRequestID from header.
func (o *ListArtifactsParams) bindXRequestID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.XRequestID = &raw

	if err := o.validateXRequestID(formats); err != nil {
		return err
	}

	return nil
}

// validateXRequestID carries on validations for parameter XRequestID
func (o *ListArtifactsParams) validateXRequestID(formats strfmt.Registry) error {

	if err := validate.MinLength("X-Request-Id", "header", (*o.XRequestID), 1); err != nil {
		return err
	}

	return nil
}

// bindPage binds and validates parameter Page from query.
func (o *ListArtifactsParams) bindPage(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewListArtifactsParams()
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("page", "query", "int64", raw)
	}
	o.Page = &value

	return nil
}

// bindPageSize binds and validates parameter PageSize from query.
func (o *ListArtifactsParams) bindPageSize(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewListArtifactsParams()
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("page_size", "query", "int64", raw)
	}
	o.PageSize = &value

	if err := o.validatePageSize(formats); err != nil {
		return err
	}

	return nil
}

// validatePageSize carries on validations for parameter PageSize
func (o *ListArtifactsParams) validatePageSize(formats strfmt.Registry) error {

	if err := validate.MaximumInt("page_size", "query", int64(*o.PageSize), 100, false); err != nil {
		return err
	}

	return nil
}

// bindProjectName binds and validates parameter ProjectName from path.
func (o *ListArtifactsParams) bindProjectName(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route

	o.ProjectName = raw

	return nil
}

// bindQ binds and validates parameter Q from query.
func (o *ListArtifactsParams) bindQ(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Q = &raw

	return nil
}

// bindRepositoryName binds and validates parameter RepositoryName from path.
func (o *ListArtifactsParams) bindRepositoryName(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route

	o.RepositoryName = raw

	return nil
}

// bindSort binds and validates parameter Sort from query.
func (o *ListArtifactsParams) bindSort(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Sort = &raw

	return nil
}

// bindWithImmutableStatus binds and validates parameter WithImmutableStatus from query.
func (o *ListArtifactsParams) bindWithImmutableStatus(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewListArtifactsParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_immutable_status", "query", "bool", raw)
	}
	o.WithImmutableStatus = &value

	return nil
}

// bindWithLabel binds and validates parameter WithLabel from query.
func (o *ListArtifactsParams) bindWithLabel(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewListArtifactsParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_label", "query", "bool", raw)
	}
	o.WithLabel = &value

	return nil
}

// bindWithScanOverview binds and validates parameter WithScanOverview from query.
func (o *ListArtifactsParams) bindWithScanOverview(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewListArtifactsParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_scan_overview", "query", "bool", raw)
	}
	o.WithScanOverview = &value

	return nil
}

// bindWithSignature binds and validates parameter WithSignature from query.
func (o *ListArtifactsParams) bindWithSignature(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewListArtifactsParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_signature", "query", "bool", raw)
	}
	o.WithSignature = &value

	return nil
}

// bindWithTag binds and validates parameter WithTag from query.
func (o *ListArtifactsParams) bindWithTag(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewListArtifactsParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("with_tag", "query", "bool", raw)
	}
	o.WithTag = &value

	return nil
}
