// Code generated by go-swagger; DO NOT EDIT.

package ldap

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"
)

// ImportLdapUserHandlerFunc turns a function with the right signature into a import ldap user handler
type ImportLdapUserHandlerFunc func(ImportLdapUserParams, interface{}) middleware.Responder

// Handle executing the request and returning a response
func (fn ImportLdapUserHandlerFunc) Handle(params ImportLdapUserParams, principal interface{}) middleware.Responder {
	return fn(params, principal)
}

// ImportLdapUserHandler interface for that can handle valid import ldap user params
type ImportLdapUserHandler interface {
	Handle(ImportLdapUserParams, interface{}) middleware.Responder
}

// NewImportLdapUser creates a new http.Handler for the import ldap user operation
func NewImportLdapUser(ctx *middleware.Context, handler ImportLdapUserHandler) *ImportLdapUser {
	return &ImportLdapUser{Context: ctx, Handler: handler}
}

/*ImportLdapUser swagger:route POST /ldap/users/import Ldap importLdapUser

Import selected available ldap users.

This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information. If have errors when import user, will return the list of importing failed uid and the failed reason.


*/
type ImportLdapUser struct {
	Context *middleware.Context
	Handler ImportLdapUserHandler
}

func (o *ImportLdapUser) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		r = rCtx
	}
	var Params = NewImportLdapUserParams()

	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		r = aCtx
	}
	var principal interface{}
	if uprinc != nil {
		principal = uprinc
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request

	o.Context.Respond(rw, r, route.Produces, route, res)

}
